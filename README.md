# Mylearn_JavaSE_Code
个人从零学习Java，看B站的黑马程序员视频教程，个人flag，2022年底学完第一系列

| **区别**  | **成员变量**   | **局部变量**                |
|---------|------------|-------------------------|
| 类中位置不同  | 类中方法外      | 方法内或者方法申明上              |
| 内存中位置不同 | 堆内存        | 栈内存                     |
| 生命周期不同  | 随着对象的存在而存在 | 随着方法的调用而存在，随着方法的调用完毕而消失 |
| 初始化值不同  | 有默认的初始化值   | 没有默认的初始化值，必须先定义，赋值，才能使用 |

---
**构造方法的注意事项**

1. 构造方法的创建

   - 如果没有定义构造方法，系统将给出一个默认的无参数构造方法

   - 如果定义了构造方法，系统将不再提供默认的构造方法

2. 构造方法的重载

   - 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法

3. 推荐的使用方式

    - ***无论是否使用，都手工书写无参数构造方法***
---
**标准类制作**

1. 成员变量

    - 使用private修饰

2. 构造方法

    - 提供一个无参构造方法

    - 提供一个带多个参数的构造方法

3. 成员方法

    - 提供每一个成员变量对应的setXxx()/getXxx() 提供一个显示对象信息的show()

4. 创建对象并为其成员变量赋值的两种方式
   - 无参构造方法创建对象后使用setXxx()
   - 赋值使用带参构造方法直接创建带有属性值的对象
---

### 枚举类型与泛型

### 枚举

- 枚举类型本质上还是以类的形式存在的。泛型的出现不仅可以让程序员少写一些代码，更重要的是它可以解决类型安全问题。
- 泛型提供了编译时的安全检查，**不会因为将对象置于某个容器中而失去其类型**。

用户可以将一个枚举类型看作是一个类，它继承于java.lang.Enum类，当定义一个枚举类型时，每一个枚举类型成员都可以看作是枚举类型的一个实例，这些枚举类型成员都默认被final、public、static修饰，所以当使用枚举类型成员时直接使用枚举类型名称调用枚举类型成员即可。

优势：
- 类型安全。
- 紧凑有效的数据定义。
- 可以和程序其他部分完美交互。
- 运行效率高。

#### 泛型

Object类为最上层的父类，很多程序员为了使程序更为通用，设计程序时通常使传入的值与返回的值都以Object类型为主。
然而当需要使用这些实例时，必须正确地将该实例转换为原来的类型，此时强制转换有概率在运行时将会发生ClassCastException异常。

为了提前预防这种问题，Java提供了泛型机制。其语法如下：
```
类名<T>
```
其中T字母只是约定俗成，其他字母其实也行。
创建该类对象时需要指定T所代表哪种具体的类型。如果不指定具体类型，T则采用Object类型。

泛型的常规用法：
1. 定义泛型类时声明多个类型
   ```java
   class MyClass<T1,T2>{  }
   ```
   实例化指定类型的对象时，就可以指定多个类型，比如
   ```
   MyClass<Boolean,Float> m = new MyClass<Boolean,Float>();
   ```
2. 定义泛型类时声明多个类型
   虽然可以在使用泛型机制时声明一个数组，但是不可以使用泛型来建立数组的实例。
3. 集合类声明容器的元素
   例如：JDK中的集合接口、集合类都被定义了泛型，其中List<E>的泛型E实际上就是element元素的首字母，Map<K,V>的泛型K和V就是key键和value值的首字母。

泛型的高级用法：
1. 限制泛型可用类型
   默认可以使用任何类型来实例化一个泛型类对象，但Java中也对泛型类实例的类型作了限制。语法如下:
   ```java
   class 类名称<T extends anyClass>{}
   ```
   使用泛型限制后，泛型类的类型必须实现或继承anyClass这个接口或类
2. 使用类型通配符
   ```
   泛型类名称<? extends List> a=null;
   ```
   其中，<? extends List>表示类型未知，当需要使用该泛型对象时，可以单独实例化
   ```
   A<? extends List> a = null;
   a = new A<ArrayList>();
   a = new A<LinkedList>();
   ```
   除了可以实例化一个限制泛型类型的实例，还可以将该实例放置在方法的参数中。例如：
   ```
   public void doSomething(A<? extends List> a){ }
   ```
   在上述代码中，定义方式有效地限制了传入doSomething()方法的参数类型。
   如果使用A<?>这种形式实例化泛型类对象，则默认表示可以将A指定为实例化Object及以下的子类类型。
   例如：
   ```
   // 实例化一个ArrayList对象
   List<String> L1 = new ArrayList<String>();
   // 在集合中添加内容
   L1.add("成员");
   List<?> L2 = L1;
   List<?> L3 = new LinkedList<Integer>()
   ```
   这里值得考究的一点是，以上“List<?> l2 = l1”语句与“List l2 = l1”语句是存在区别的：
   使用通配符声明的名称实例化的对象**不能对其加入新的信息**，只能获取或删除。
   比如上述的L2、L3使用类通配符方式创建出来的，不能使用List类带有的set方法改变集合中的值。
   
   `note: 泛型类型限制除了可以向下限制，还可以进行向上限制，只要在定义时使用super关键字即可。例如，“A<? super List> a = null;”这样定义后，对象a只接受List接口或上层父类类型，如“a = new A<Object>();”。`
   
3. 继承泛型类与实现泛型接口
   定义为泛型的类和接口也可以被继承与实现。例如，让SubClass类继承ExtendClass的泛型，代码如下：
   ```java
   class ExtendClass<T1>{ }
   class SubClass<T1,T2,T3> extends ExtendClass<T1>{ }
   ```
   如果在SubClass类继承ExtendClass类时保留父类的泛型类型，需要在继承时指明，如果没有指明，直接使用“extends ExtendsClass”语句进行继承操作，则SubClass类中的T1、T2和T3都会自动变为Object类型，所以在一般情况下都将父类的泛型类型保留。

   定义为泛型的接口也可以被实现。例如，让SubClass类实现SomeInterface接口，并继承接口的泛型，代码如下
   ```java
   interface SomeInterface<T1>{ }
   class SubClass<T1,T2,T3> implements SomeInterface<T1>{ }
   ```

**总结：**
- 泛型的类型参数只能是类类型，不可以是简单类型，如A<int>这种泛型定义就是错误的。
- 泛型的类型个数可以是多个。
- 可以使用extends关键字限制泛型的类型。
- 可以使用通配符限制泛型的类型。